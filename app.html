<!DOCTYPE html> 
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Momentum Maze · Cyber Themes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        :root {
            --bg: #050111;
            --bg-alt: #080018;
            --accent: #00f5ff;
            --accent-2: #ff00e5;
            --text-main: #f4f5ff;
            --text-soft: #a0a3c5;
            --panel-bg: rgba(8, 0, 32, 0.9);
            --shadow-soft: 0 0 40px rgba(0, 0, 0, 0.9);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            min-height: 100vh;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background:
                radial-gradient(circle at 10% 0%, rgba(255, 0, 229, 0.2), transparent 55%),
                radial-gradient(circle at 90% 100%, rgba(0, 245, 255, 0.2), transparent 55%),
                linear-gradient(135deg, var(--bg), var(--bg-alt));
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .shell {
            width: 100%;
            max-width: 960px;
            background:
                radial-gradient(circle at top left, rgba(0, 245, 255, 0.12), transparent 60%),
                radial-gradient(circle at bottom right, rgba(255, 0, 229, 0.12), transparent 60%),
                linear-gradient(145deg, rgba(11, 3, 40, 0.96), rgba(4, 0, 20, 0.98));
            border-radius: 22px;
            border: 1px solid rgba(180, 200, 255, 0.18);
            box-shadow: var(--shadow-soft);
            padding: 10px 12px 30px; /* extra bottom padding so link isn't cramped */
            position: relative;
            overflow: hidden;
        }

        .shell::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: inherit;
            border: 1px solid rgba(0, 245, 255, 0.05);
            mix-blend-mode: screen;
            pointer-events: none;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 2px 2px 8px;
            border-bottom: 1px solid rgba(163, 177, 255, 0.25);
        }

        header .title-wrap {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        header h1 {
            font-size: 1.1rem;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            display: inline-flex;
            align-items: center;
            gap: 0.55rem;
        }

        header h1 span.accent {
            font-weight: 700;
            color: var(--accent);
            text-shadow:
                0 0 6px rgba(0, 245, 255, 0.8),
                0 0 18px rgba(0, 245, 255, 0.6);
        }

        header h1 span.subtle {
            font-weight: 500;
            color: var(--text-soft);
        }

        header p.subtitle {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--text-soft);
        }

        .theme-select-wrap {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 3px;
            font-size: 0.68rem;
        }

        .theme-select-wrap label {
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--text-soft);
        }

        #themeSelect {
            font-size: 0.7rem;
            padding: 3px 7px;
            border-radius: 999px;
            border: 1px solid rgba(164, 175, 255, 0.7);
            background: rgba(6, 4, 28, 0.96);
            color: var(--text-main);
            outline: none;
        }

        #themeSelect:focus {
            border-color: var(--accent);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.6);
        }

        /* GAME PANEL */

        .game-panel {
            margin-top: 8px;
            background: var(--panel-bg);
            border-radius: 18px;
            border: 1px solid rgba(111, 120, 190, 0.4);
            padding: 10px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .game-panel::before {
            content: "";
            position: absolute;
            inset: 0;
            background-image: linear-gradient(
                rgba(255, 255, 255, 0.04) 1px,
                transparent 1px
            );
            background-size: 100% 26px;
            opacity: 0.35;
            mix-blend-mode: soft-light;
            pointer-events: none;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            z-index: 1;
        }

        .hud-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .hud-pill {
            background: radial-gradient(circle at 0 0, rgba(0, 245, 255, 0.25), transparent 55%);
            border-radius: 999px;
            border: 1px solid rgba(0, 245, 255, 0.5);
            padding: 3px 8px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--text-main);
            white-space: nowrap;
        }

        .hud-pill.secondary {
            background: radial-gradient(circle at 100% 0, rgba(255, 0, 229, 0.22), transparent 60%);
            border-color: rgba(255, 0, 229, 0.6);
        }

        .hud-label {
            color: var(--text-soft);
        }

        .hud-value {
            font-weight: 600;
            color: var(--accent);
        }

        .hud-value.secondary {
            color: var(--accent-2);
        }

        .hud-buttons {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .btn {
            border-radius: 999px;
            border: 1px solid rgba(164, 175, 255, 0.5);
            background: radial-gradient(circle at 0 0, rgba(0, 245, 255, 0.15), transparent 55%);
            padding: 5px 10px;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: var(--text-main);
            cursor: pointer;
            outline: none;
            transition: transform 0.09s ease, box-shadow 0.12s ease,
                        background 0.2s ease, border-color 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn span.icon {
            font-size: 0.8rem;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 16px rgba(0, 245, 255, 0.55);
            border-color: var(--accent);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: 0 0 4px rgba(0, 245, 255, 0.5);
        }

        .btn-quiet {
            border-style: dashed;
            border-color: rgba(164, 175, 255, 0.3);
            background: transparent;
            color: var(--text-soft);
        }

        .btn-quiet:hover {
            border-color: rgba(164, 175, 255, 0.7);
            box-shadow: 0 0 10px rgba(164, 175, 255, 0.5);
        }

        .canvas-wrap {
            margin-top: 4px;
            position: relative;
            border-radius: 16px;
            padding: 1px;
            background: linear-gradient(
                130deg,
                rgba(0, 245, 255, 0.9),
                rgba(255, 0, 229, 0.5),
                rgba(0, 245, 255, 0.8)
            );
            box-shadow:
                0 0 25px rgba(0, 245, 255, 0.45),
                0 0 32px rgba(255, 0, 229, 0.35);
        }

        .canvas-inner {
            border-radius: inherit;
            background:
                radial-gradient(circle at 20% 0, rgba(0, 245, 255, 0.12), transparent 60%),
                radial-gradient(circle at 80% 100%, rgba(255, 0, 229, 0.12), transparent 60%),
                radial-gradient(circle at 50% 30%, rgba(255, 255, 255, 0.03), transparent 65%),
                #02010a;
            padding: 8px;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 360px;
            border-radius: 14px;
            background: transparent;
        }

        @media (max-width: 720px) {
            #gameCanvas {
                height: 260px;
            }
        }

        .hint-row {
            margin-top: 4px;
            font-size: 0.73rem;
            color: var(--text-soft);
            display: flex;
            justify-content: space-between;
            gap: 6px;
            flex-wrap: wrap;
        }

        .key-badge {
            border-radius: 6px;
            border: 1px solid rgba(172, 178, 255, 0.5);
            padding: 1px 6px 2px;
            font-size: 0.62rem;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            background: rgba(5, 5, 30, 0.7);
            margin-right: 6px;
        }

        /* CLICK EFFECT / FLASH */

        .flash-message {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .flash-message.visible {
            opacity: 1;
        }

        .flash-inner {
            padding: 8px 14px;
            border-radius: 999px;
            border: 1px solid rgba(0, 245, 255, 0.7);
            background: radial-gradient(circle at 0 0, rgba(0, 245, 255, 0.35), transparent 60%),
                        rgba(2, 0, 18, 0.96);
            color: var(--text-main);
            font-size: 0.72rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow:
                0 0 18px rgba(0, 245, 255, 0.9),
                0 0 26px rgba(0, 0, 0, 0.9);
        }

        .flash-inner span.main {
            color: #63ffba;
        }

        .flash-inner span.sub {
            color: var(--text-soft);
        }

        /* INTRO OVERLAY */

        .intro-overlay {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 20% 0, rgba(0, 245, 255, 0.15), transparent 65%),
                        radial-gradient(circle at 80% 100%, rgba(255, 0, 229, 0.2), transparent 65%),
                        rgba(1, 0, 10, 0.92);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .intro-overlay.hidden {
            display: none;
        }

        .intro-panel {
            max-width: 420px;
            width: 100%;
            border-radius: 18px;
            padding: 14px 16px 16px;
            background: linear-gradient(145deg, rgba(5, 0, 25, 0.98), rgba(10, 0, 35, 0.98));
            border: 1px solid rgba(0, 245, 255, 0.6);
            box-shadow:
                0 0 32px rgba(0, 245, 255, 0.7),
                0 0 40px rgba(0, 0, 0, 0.9);
        }

        .intro-label {
            font-size: 0.68rem;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--text-soft);
            margin-bottom: 4px;
        }

        .intro-title {
            font-size: 1rem;
            margin-bottom: 6px;
        }

        .intro-title span {
            color: var(--accent);
        }

        .intro-text {
            font-size: 0.8rem;
            color: var(--text-soft);
            margin-bottom: 8px;
        }

        .intro-list {
            list-style: none;
            margin-bottom: 10px;
            font-size: 0.78rem;
            color: var(--text-soft);
            display: grid;
            gap: 4px;
        }

        .intro-list li {
            display: flex;
            gap: 6px;
            align-items: flex-start;
        }

        .intro-bullet {
            width: 7px;
            height: 7px;
            border-radius: 999px;
            margin-top: 3px;
            background: radial-gradient(circle, var(--accent), var(--accent-2));
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.8);
            flex-shrink: 0;
        }

        .intro-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-top: 2px;
        }

        .intro-footer span {
            font-size: 0.7rem;
            color: var(--text-soft);
        }

        .btn-intro {
            border-radius: 999px;
            border: 1px solid rgba(0, 245, 255, 0.9);
            background: radial-gradient(circle at 0 0, rgba(0, 245, 255, 0.35), transparent 60%);
            padding: 6px 14px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: var(--text-main);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.6);
        }

        .btn-intro:hover {
            box-shadow: 0 0 26px rgba(0, 245, 255, 0.9);
        }

        /* ==== BOTTOM-LEFT INDEX LINK ==== */

        .back-link {
            position: absolute;
            bottom: 8px;
            left: 14px;
            font-size: 17px;
            text-decoration: none;
            font-weight: normal;
            color: var(--accent);
        }

        .back-link:hover {
            text-decoration: underline;
            font-weight: bold;
            font-size: 19px;
        }
    </style>
</head>
<body>
<div class="shell">
    <header>
        <div class="title-wrap">
            <h1>
                <span class="accent">Momentum Maze</span>
                <span class="subtle">Neon Inertia</span>
            </h1>
            <p class="subtitle">Click to push · Ride the momentum</p>
        </div>
        <div class="theme-select-wrap">
            <label for="themeSelect">Theme</label>
            <select id="themeSelect">
                <option value="cyberpunk">Cyberpunk</option>
                <option value="synthwave">Synthwave</option>
                <option value="midnight">Midnight</option>
            </select>
        </div>
    </header>

    <section class="game-panel">
        <div class="hud-row">
            <div class="hud-group">
                <div class="hud-pill">
                    <span class="hud-label">Level</span>
                    <span class="hud-value" id="hudLevel">1</span>
                </div>
                <div class="hud-pill secondary">
                    <span class="hud-label">Time</span>
                    <span class="hud-value secondary" id="hudTime">0.0s</span>
                </div>
                <div class="hud-pill">
                    <span class="hud-label">Clicks</span>
                    <span class="hud-value" id="hudClicks">0</span>
                </div>
                <div class="hud-pill secondary">
                    <span class="hud-label">Best</span>
                    <span class="hud-value secondary" id="hudBest">—</span>
                </div>
            </div>
            <div class="hud-buttons">
                <button class="btn" id="btnResetLevel">
                    <span class="icon">⟲</span>
                    RESET LVL
                </button>
                <button class="btn btn-quiet" id="btnResetAll">
                    <span class="icon">✕</span>
                    RESET ALL
                </button>
            </div>
        </div>

        <div class="canvas-wrap">
            <div class="canvas-inner">
                <canvas id="gameCanvas"></canvas>
            </div>
            <div class="flash-message" id="flash">
                <div class="flash-inner">
                    <span class="main" id="flashMain">Level Up</span>
                    <span class="sub" id="flashSub">Maze reconfigured</span>
                </div>
            </div>
        </div>

        <div class="hint-row">
            <span><span class="key-badge">Click</span>Push the ball away from your cursor. Small taps = control.</span>
            <span id="statusText">Click OK to start, then reach the glowing gate on the right.</span>
        </div>
    </section>

    <!-- INTRO POPUP -->
    <div class="intro-overlay" id="introOverlay">
        <div class="intro-panel">
            <div class="intro-label">Momentum Maze · Controls</div>
            <div class="intro-title">
                Shape <span>inertia</span>, not arrows.
            </div>
            <p class="intro-text">
                You don’t steer with keys. Each click acts like a gravity sling, pushing the ball away
                from your cursor. Avoid the neon walls and slide into the glowing gate.
            </p>
            <ul class="intro-list">
                <li>
                    <span class="intro-bullet"></span>
                    <span><strong>Click anywhere</strong> inside the arena to push the ball away from your cursor.</span>
                </li>
                <li>
                    <span class="intro-bullet"></span>
                    <span><strong>Small, repeated taps</strong> = more control than one huge launch.</span>
                </li>
                <li>
                    <span class="intro-bullet"></span>
                    <span>Touching neon walls resets the current run. The gate on the right advances the level.</span>
                </li>
                <li>
                    <span class="intro-bullet"></span>
                    <span>Use <strong>RESET LVL</strong> or <strong>RESET ALL</strong> if you want a fresh setup.</span>
                </li>
            </ul>
            <div class="intro-footer">
                <span>Press OK when you’re ready.</span>
                <button class="btn-intro" id="btnIntroOk">
                    <span>OK · START</span>
                </button>
            </div>
        </div>
    </div>

    <!-- BOTTOM-LEFT LINK BACK TO INDEX -->
    <a href="index.html" class="back-link">Index / Scratch Page</a>
</div>

<script>
(function () {
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const hudLevel  = document.getElementById("hudLevel");
    const hudTime   = document.getElementById("hudTime");
    const hudClicks = document.getElementById("hudClicks");
    const hudBest   = document.getElementById("hudBest");
    const statusText = document.getElementById("statusText");

    const flashEl    = document.getElementById("flash");
    const flashMain  = document.getElementById("flashMain");
    const flashSub   = document.getElementById("flashSub");

    const btnResetLevel = document.getElementById("btnResetLevel");
       const btnResetAll   = document.getElementById("btnResetAll");

    const introOverlay = document.getElementById("introOverlay");
    const btnIntroOk   = document.getElementById("btnIntroOk");

    const themeSelect  = document.getElementById("themeSelect");
    const shell        = document.querySelector(".shell");

    let introActive = true;

    let pixelRatio = window.devicePixelRatio || 1;

    /* THEME DEFINITIONS */

    const themeVars = {
        cyberpunk: {
            "--bg": "#050111",
            "--bg-alt": "#080018",
            "--accent": "#00f5ff",
            "--accent-2": "#ff00e5",
            "--panel-bg": "rgba(8, 0, 32, 0.9)",
            "--text-main": "#f4f5ff",
            "--text-soft": "#a0a3c5"
        },
        synthwave: {
            "--bg": "#12001f",
            "--bg-alt": "#260033",
            "--accent": "#ff6bcb",
            "--accent-2": "#ffe45e",
            "--panel-bg": "rgba(18, 0, 45, 0.96)",
            "--text-main": "#ffeaff",
            "--text-soft": "#f2b5ff"
        },
        midnight: {
            "--bg": "#02040b",
            "--bg-alt": "#05091a",
            "--accent": "#4dd0e1",
            "--accent-2": "#80cbc4",
            "--panel-bg": "rgba(3, 8, 24, 0.96)",
            "--text-main": "#e0f7fa",
            "--text-soft": "#90a4ae"
        }
    };

    const themeColors = {
        cyberpunk: {
            bg1: "#030013",
            bg2: "#050117",
            bg3: "#02000b",
            grid: "rgba(90, 100, 170, 0.3)",
            border1: "rgba(0, 245, 255, 0.5)",
            borderMid: "rgba(255, 0, 229, 0.5)",
            border2: "rgba(0, 245, 255, 0.5)",
            borderGlow: "rgba(0, 245, 255, 0.4)",
            obstacleFill: "rgba(2, 0, 30, 0.7)",
            obstacleStart: "rgba(0, 245, 255, 0.85)",
            obstacleEnd: "rgba(255, 0, 229, 0.85)",
            gateFill: "rgba(5, 30, 25, 0.85)",
            gateGradStart: "rgba(99, 255, 186, 0.1)",
            gateGradMid: "rgba(99, 255, 186, 0.6)",
            gateGradEnd: "rgba(0, 245, 255, 0.8)",
            gateGlow: "rgba(99, 255, 186, 0.9)",
            gateStripe: "rgba(99, 255, 186, 0.5)",
            clickRing: "rgba(0, 245, 255, 0.9)",
            trailInner: "rgba(0, 245, 255, 0.55)",
            trailOuter: "rgba(0, 245, 255, 0.0)",
            ballCore: "#ffffff",
            ballMid: "#00f5ff",
            ballEdge: "#350050",
            ballGlow: "rgba(0, 245, 255, 0.9)",
            velLine: "rgba(0, 245, 255, 0.7)"
        },
        synthwave: {
            bg1: "#1b0030",
            bg2: "#33004b",
            bg3: "#120020",
            grid: "rgba(255, 107, 203, 0.35)",
            border1: "rgba(255, 107, 203, 0.7)",
            borderMid: "rgba(255, 228, 94, 0.7)",
            border2: "rgba(255, 107, 203, 0.7)",
            borderGlow: "rgba(255, 107, 203, 0.55)",
            obstacleFill: "rgba(25, 0, 40, 0.85)",
            obstacleStart: "rgba(255, 107, 203, 0.9)",
            obstacleEnd: "rgba(255, 228, 94, 0.9)",
            gateFill: "rgba(35, 0, 40, 0.9)",
            gateGradStart: "rgba(255, 228, 94, 0.15)",
            gateGradMid: "rgba(255, 228, 94, 0.7)",
            gateGradEnd: "rgba(255, 107, 203, 0.85)",
            gateGlow: "rgba(255, 228, 94, 0.9)",
            gateStripe: "rgba(255, 228, 94, 0.6)",
            clickRing: "rgba(255, 107, 203, 0.9)",
            trailInner: "rgba(255, 107, 203, 0.6)",
            trailOuter: "rgba(255, 107, 203, 0.0)",
            ballCore: "#ffffff",
            ballMid: "#ff6bcb",
            ballEdge: "#ffb6ff",
            ballGlow: "rgba(255, 107, 203, 0.9)",
            velLine: "rgba(255, 228, 94, 0.9)"
        },
        midnight: {
            bg1: "#02040b",
            bg2: "#05091a",
            bg3: "#00040f",
            grid: "rgba(77, 208, 225, 0.25)",
            border1: "rgba(77, 208, 225, 0.7)",
            borderMid: "rgba(128, 203, 196, 0.7)",
            border2: "rgba(77, 208, 225, 0.7)",
            borderGlow: "rgba(77, 208, 225, 0.5)",
            obstacleFill: "rgba(2, 10, 25, 0.85)",
            obstacleStart: "rgba(77, 208, 225, 0.9)",
            obstacleEnd: "rgba(128, 203, 196, 0.9)",
            gateFill: "rgba(1, 18, 28, 0.9)",
            gateGradStart: "rgba(224, 247, 250, 0.16)",
            gateGradMid: "rgba(128, 222, 234, 0.7)",
            gateGradEnd: "rgba(77, 208, 225, 0.85)",
            gateGlow: "rgba(128, 222, 234, 0.95)",
            gateStripe: "rgba(128, 222, 234, 0.6)",
            clickRing: "rgba(128, 222, 234, 0.95)",
            trailInner: "rgba(77, 208, 225, 0.6)",
            trailOuter: "rgba(77, 208, 225, 0.0)",
            ballCore: "#e0f7fa",
            ballMid: "#4dd0e1",
            ballEdge: "#006064",
            ballGlow: "rgba(77, 208, 225, 0.95)",
            velLine: "rgba(128, 222, 234, 0.9)"
        }
    };

    let currentTheme = "cyberpunk";

    function applyTheme(name) {
        currentTheme = name;
        const vars = themeVars[name];
        const rootStyle = document.documentElement.style;
        for (const key in vars) {
            rootStyle.setProperty(key, vars[key]);
        }

        if (name === "cyberpunk") {
            shell.style.background =
                "radial-gradient(circle at top left, rgba(0,245,255,0.12), transparent 60%)," +
                "radial-gradient(circle at bottom right, rgba(255,0,229,0.12), transparent 60%)," +
                "linear-gradient(145deg, rgba(11,3,40,0.96), rgba(4,0,20,0.98))";
        } else if (name === "synthwave") {
            shell.style.background =
                "radial-gradient(circle at top left, rgba(255,107,203,0.16), transparent 60%)," +
                "radial-gradient(circle at bottom right, rgba(255,228,94,0.2), transparent 60%)," +
                "linear-gradient(145deg, rgba(32,0,60,0.98), rgba(15,0,38,0.98))";
        } else if (name === "midnight") {
            shell.style.background =
                "radial-gradient(circle at top left, rgba(77,208,225,0.14), transparent 60%)," +
                "radial-gradient(circle at bottom right, rgba(128,203,196,0.16), transparent 60%)," +
                "linear-gradient(145deg, rgba(3,10,30,0.98), rgba(1,4,16,0.98))";
        }
    }

    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        pixelRatio = window.devicePixelRatio || 1;
        canvas.width  = rect.width * pixelRatio;
        canvas.height = rect.height * pixelRatio;
        ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    }

    window.addEventListener("resize", resizeCanvas, { passive: true });
    resizeCanvas();

    // GAME STATE
    const ball = {
        x: 0,
        y: 0,
        r: 12,
        vx: 0,
        vy: 0
    };

    const goal = {
        x: 0,
        y: 0,
        w: 28,
        h: 80
    };

    let obstacles = [];

    // Click ripple effects
    const clickEffects = [];

    // RUN STATS
    let level = 1;
    let clickCount = 0;
    let bestTime = null;
    let runTime = 0;
    let started = false;
    let lastTimestamp = 0;

    // PHYSICS CONSTANTS (slightly faster)
    const friction = 0.985;
    const impulseBase = 0.28;
    const maxSpeed = 8;
    const wallBounce = 0.8;

    function resetBall() {
        const w = canvas.width / pixelRatio;
        const h = canvas.height / pixelRatio;

        ball.x = w * 0.12;
        ball.y = h * 0.5;
        ball.vx = 0;
        ball.vy = 0;

        started = false;
        runTime = 0;
    }

    function configureGoal() {
        const w = canvas.width / pixelRatio;
        const h = canvas.height / pixelRatio;
        goal.w = 28;
        goal.h = Math.min(110, h * 0.45);
        goal.x = w - goal.w - 16;
        goal.y = h * 0.5 - goal.h / 2;
    }

    function randomRange(min, max) {
        return min + Math.random() * (max - min);
    }

    function generateObstacles() {
        const w = canvas.width / pixelRatio;
        const h = canvas.height / pixelRatio;
        const marginX = 60;
        const marginY = 30;
        const playableW = w - marginX * 2;
        const playableH = h - marginY * 2;

        obstacles = [];

        const rows = 3 + Math.min(level, 4);
        const cols = 4;
        const cellW = playableW / cols;
        const cellH = playableH / rows;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (Math.random() < 0.35) continue;

                const x = marginX + col * cellW + cellW * 0.18;
                const y = marginY + row * cellH + cellH * 0.18;
                const wObs = cellW * randomRange(0.3, 0.55);
                const hObs = cellH * randomRange(0.25, 0.45);

                if (x < marginX + 40 && y < h * 0.75 && y + hObs > h * 0.25) continue;
                if (x + wObs > goal.x - 40 && y < h * 0.75 && y + hObs > h * 0.25) continue;

                const axis = Math.random() < 0.5 ? "x" : "y";
                const amp = axis === "x"
                    ? cellW * randomRange(0.1, 0.25)
                    : cellH * randomRange(0.1, 0.25);

                const speed = randomRange(0.3, 0.7) + level * 0.04;

                obstacles.push({
                    baseX: x,
                    baseY: y,
                    w: wObs,
                    h: hObs,
                    axis,
                    amplitude: amp,
                    speed,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
    }

    function updateHUD() {
        hudLevel.textContent  = level;
        hudClicks.textContent = clickCount;
        hudTime.textContent   = runTime.toFixed(1) + "s";
        hudBest.textContent   = bestTime == null ? "—" : bestTime.toFixed(1) + "s";
    }

    function setStatus(msg) {
        statusText.textContent = msg;
    }

    function resetLevelOnly() {
        clickCount = 0;
        runTime = 0;
        started = false;
        clickEffects.length = 0;
        generateObstacles();
        resetBall();
        updateHUD();
        setStatus("Level " + level + " reset.");
    }

    function resetAll() {
        level = 1;
        bestTime = null;
        clickCount = 0;
        runTime = 0;
        started = false;
        clickEffects.length = 0;
        configureGoal();
        generateObstacles();
        resetBall();
        updateHUD();
        setStatus("All progress reset. Back to Level 1.");
    }

    // INTRO OVERLAY BUTTON
    btnIntroOk.addEventListener("click", () => {
        introActive = false;
        introOverlay.classList.add("hidden");
        setStatus("Click inside the arena to launch the ball.");
    });

    // THEME SELECT
    themeSelect.addEventListener("change", (e) => {
        applyTheme(e.target.value);
    });

    // INPUT: click to push
    canvas.addEventListener("click", function (event) {
        if (introActive) return; // block input until OK pressed

        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left);
        const y = (event.clientY - rect.top);

        const cx = x;
        const cy = y;

        // direction from click to ball (push ball away from cursor)
        const dx = ball.x - cx;
        const dy = ball.y - cy;
        const dist = Math.hypot(dx, dy) || 1;

        const strength = impulseBase * (1 + Math.min(dist / 180, 1.5));

        ball.vx += (dx / dist) * strength;
        ball.vy += (dy / dist) * strength;

        // Clamp speed
        const speed = Math.hypot(ball.vx, ball.vy);
        if (speed > maxSpeed) {
            ball.vx = (ball.vx / speed) * maxSpeed;
            ball.vy = (ball.vy / speed) * maxSpeed;
        }

        clickCount++;
        started = true;

        // Add click ripple effect
        clickEffects.push({
            x: cx,
            y: cy,
            age: 0
        });

        updateHUD();
    });

    // Buttons
    btnResetLevel.addEventListener("click", function () {
        resetLevelOnly();
    });

    btnResetAll.addEventListener("click", function () {
        resetAll();
    });

    // COLLISION HELPERS
    function circleRectCollision(circle, rect) {
        const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
        const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
        const dx = circle.x - closestX;
        const dy = circle.y - closestY;
        const distSq = dx * dx + dy * dy;
        return distSq < circle.r * circle.r;
    }

    function resolveCircleRect(circle, rect) {
        const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
        const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
        const dx = circle.x - closestX;
        const dy = circle.y - closestY;
        let dist = Math.hypot(dx, dy) || 1;
        const overlap = circle.r - dist;
        if (overlap > 0) {
            const nx = dx / dist;
            const ny = dy / dist;

            circle.x += nx * overlap;
            circle.y += ny * overlap;

            const dot = circle.vx * nx + circle.vy * ny;
            circle.vx = circle.vx - 2 * dot * nx;
            circle.vy = circle.vy - 2 * dot * ny;

            circle.vx *= wallBounce;
            circle.vy *= wallBounce;
        }
    }

    // FLASH / LEVEL-UP MESSAGE
    function showFlash(mainText, subText, durationMs) {
        flashMain.textContent = mainText;
        flashSub.textContent  = subText;
        flashEl.classList.add("visible");
        setTimeout(() => {
            flashEl.classList.remove("visible");
        }, durationMs || 900);
    }

    // UPDATE LOOP
    function update(dt, timeSec) {
        const w = canvas.width / pixelRatio;
        const h = canvas.height / pixelRatio;

        if (started) {
            runTime += dt * (1 / 60);
        }

        // Friction + movement
        ball.vx *= friction;
        ball.vy *= friction;
        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        // Walls (bounds)
        if (ball.x - ball.r < 6) {
            ball.x = 6 + ball.r;
            ball.vx = Math.abs(ball.vx) * wallBounce;
        }
        if (ball.x + ball.r > w - 6) {
            ball.x = w - 6 - ball.r;
            ball.vx = -Math.abs(ball.vx) * wallBounce;
        }
        if (ball.y - ball.r < 6) {
            ball.y = 6 + ball.r;
            ball.vy = Math.abs(ball.vy) * wallBounce;
        }
        if (ball.y + ball.r > h - 6) {
            ball.y = h - 6 - ball.r;
            ball.vy = -Math.abs(ball.vy) * wallBounce;
        }

        // Obstacles (animated)
        const animatedRects = [];
        for (const o of obstacles) {
            const offset = Math.sin(timeSec * o.speed + o.phase) * o.amplitude;
            const rx = o.axis === "x" ? o.baseX + offset : o.baseX;
            const ry = o.axis === "y" ? o.baseY + offset : o.baseY;
            animatedRects.push({ x: rx, y: ry, w: o.w, h: o.h });
        }

        // Collision with obstacles
        let collided = false;
        for (const rect of animatedRects) {
            if (circleRectCollision(ball, rect)) {
                collided = true;
                resolveCircleRect(ball, rect);
            }
        }

        if (collided && started) {
            showFlash("Hit Wall", "Run reset. Try a softer line.", 850);
            resetBall();
            runTime = 0;
            clickCount = 0;
            setStatus("Neon wall contact resets the run.");
        }

        // Goal check
        const goalRect = { x: goal.x, y: goal.y, w: goal.w, h: goal.h };
        if (
            ball.x + ball.r > goalRect.x &&
            ball.x - ball.r < goalRect.x + goalRect.w &&
            ball.y + ball.r > goalRect.y &&
            ball.y - ball.r < goalRect.y + goalRect.h
        ) {
            if (started) {
                if (bestTime == null || runTime < bestTime) {
                    bestTime = runTime;
                }
            }
            level++;
            showFlash("Level " + level, "Maze shifted.", 1000);
            setStatus("New layout, same physics. Keep the flow.");
            runTime = 0;
            clickCount = 0;
            started = false;
            generateObstacles();
            resetBall();
        }

        // Update click effects
        for (let i = clickEffects.length - 1; i >= 0; i--) {
            clickEffects[i].age += dt * (1 / 60);
            if (clickEffects[i].age > 0.4) {
                clickEffects.splice(i, 1);
            }
        }

        updateHUD();
    }

    // DRAW LOOP
    function draw(timestamp) {
        const w = canvas.width / pixelRatio;
        const h = canvas.height / pixelRatio;
        const c = themeColors[currentTheme];

        ctx.save();
        ctx.clearRect(0, 0, w, h);

        const timeSec = timestamp / 1000;

        // Background gradient
        const bgGrad = ctx.createLinearGradient(0, 0, w, h);
        bgGrad.addColorStop(0, c.bg1);
        bgGrad.addColorStop(0.5, c.bg2);
        bgGrad.addColorStop(1, c.bg3);
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, w, h);

        // Grid lines
        ctx.lineWidth = 1;
        ctx.strokeStyle = c.grid;
        const gridSize = 26;
        const offset = (timeSec * 8) % gridSize;

        ctx.beginPath();
        for (let x = -offset; x < w; x += gridSize) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
        }
        for (let y = offset; y < h; y += gridSize) {
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
        }
        ctx.stroke();

        // Edge glow
        const borderGrad = ctx.createLinearGradient(0, 0, w, 0);
        borderGrad.addColorStop(0, c.border1);
        borderGrad.addColorStop(0.5, c.borderMid);
        borderGrad.addColorStop(1, c.border2);

        ctx.strokeStyle = borderGrad;
        ctx.lineWidth = 2;
        ctx.shadowColor = c.borderGlow;
        ctx.shadowBlur = 14;
        ctx.strokeRect(3, 3, w - 6, h - 6);

        ctx.shadowBlur = 0;

        // Animated obstacles
        for (const o of obstacles) {
            const offsetOb = Math.sin(timeSec * o.speed + o.phase) * o.amplitude;
            const rx = o.axis === "x" ? o.baseX + offsetOb : o.baseX;
            const ry = o.axis === "y" ? o.baseY + offsetOb : o.baseY;

            const grad = ctx.createLinearGradient(rx, ry, rx + o.w, ry + o.h);
            grad.addColorStop(0, c.obstacleStart);
            grad.addColorStop(1, c.obstacleEnd);

            ctx.save();
            ctx.beginPath();
            ctx.roundRect(rx, ry, o.w, o.h, 6);
            ctx.fillStyle = c.obstacleFill;
            ctx.fill();

            ctx.strokeStyle = grad;
            ctx.lineWidth = 2;
            ctx.shadowColor = c.obstacleStart;
            ctx.shadowBlur = 14;
            ctx.stroke();
            ctx.restore();
        }

        // Goal gate
        const gatePulse = (Math.sin(timeSec * 3) + 1) / 2;
        const gateWidth = goal.w;
        const gateX = goal.x;
        const gateY = goal.y;
        const gateH = goal.h;

        const gateGrad = ctx.createLinearGradient(gateX, gateY, gateX + gateWidth, gateY + gateH);
        gateGrad.addColorStop(0, c.gateGradStart);
        gateGrad.addColorStop(0.5, c.gateGradMid);
        gateGrad.addColorStop(1, c.gateGradEnd);

        ctx.save();
        ctx.beginPath();
        ctx.roundRect(gateX, gateY, gateWidth, gateH, 10);
        ctx.fillStyle = c.gateFill;
        ctx.fill();

        ctx.lineWidth = 3;
        ctx.strokeStyle = gateGrad;
        ctx.shadowColor = c.gateGlow;
        ctx.shadowBlur = 18 + gatePulse * 10;
        ctx.stroke();

        // Inner stripes
        ctx.shadowBlur = 0;
        ctx.lineWidth = 1;
        ctx.strokeStyle = c.gateStripe;
        for (let i = 0; i < 4; i++) {
            const yy = gateY + (gateH * (i + 0.5)) / 4;
            ctx.beginPath();
            ctx.moveTo(gateX + 4, yy);
            ctx.lineTo(gateX + gateWidth - 4, yy);
            ctx.stroke();
        }
        ctx.restore();

        // Click ripple effects
        for (const eff of clickEffects) {
            const t = eff.age / 0.4; // 0 -> 1
            const radius = 8 + t * 28;
            const alpha = 1 - t;

            ctx.save();
            ctx.globalAlpha = alpha * 0.8;
            ctx.strokeStyle = c.clickRing;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(eff.x, eff.y, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        // Ball trail
        const speed = Math.hypot(ball.vx, ball.vy);
        const trailLen = Math.min(1.0, speed / maxSpeed) * 18;
        if (trailLen > 2) {
            const tx = ball.x - (ball.vx || 0) * trailLen * 0.35;
            const ty = ball.y - (ball.vy || 0) * trailLen * 0.35;
            const gradTrail = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.r * 3);
            gradTrail.addColorStop(0, c.trailInner);
            gradTrail.addColorStop(1, c.trailOuter);

            ctx.save();
            ctx.globalAlpha = 0.65;
            ctx.fillStyle = gradTrail;
            ctx.beginPath();
            ctx.ellipse(tx, ty, ball.r * 3.2, ball.r * 3.2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Ball
        ctx.save();
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);

        const ballGrad = ctx.createRadialGradient(
            ball.x - ball.r * 0.4,
            ball.y - ball.r * 0.4,
            1,
            ball.x,
            ball.y,
            ball.r
        );
        ballGrad.addColorStop(0, c.ballCore);
        ballGrad.addColorStop(0.3, c.ballMid);
        ballGrad.addColorStop(1, c.ballEdge);

        ctx.fillStyle = ballGrad;
        ctx.shadowColor = c.ballGlow;
        ctx.shadowBlur = 16;
        ctx.fill();

        ctx.lineWidth = 1.2;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
        ctx.stroke();
        ctx.restore();

        // Ball velocity indicator
        ctx.save();
        ctx.lineWidth = 1;
        ctx.strokeStyle = c.velLine;
        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(ball.x + ball.vx * 4, ball.y + ball.vy * 4);
        ctx.stroke();
        ctx.restore();

        ctx.restore();
    }

    function loop(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const deltaMs = timestamp - lastTimestamp;
        lastTimestamp = timestamp;

        const dt = Math.max(0.5, Math.min(2.0, deltaMs / 16.67)); // Normalize to ~60fps
        const timeSec = timestamp / 1000;

        update(dt, timeSec);
        draw(timestamp);

        requestAnimationFrame(loop);
    }

    // INITIALIZE
    applyTheme("cyberpunk");
    configureGoal();
    generateObstacles();
    resetBall();
    updateHUD();
    setStatus("Click OK to close the instructions, then click in the arena to move.");

    requestAnimationFrame(loop);
})();
</script>
</body>
</html>
